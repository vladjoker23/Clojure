# Cojure
Clojure — современный диалект Лиспа, язык программирования общего назначения с поддержкой разработки в интерактивном режиме, поощряющий функциональное программирование и упрощающий поддержку многопоточности. Clojure работает на платформах JVM и CLR. Clojure отличает философия «код как данные» (гомоиконность) и развитая система лисп-макросов.

Транслятор Clojure свободно распространяется на условиях Eclipse Public License.
Рич Хикки разработал Clojure как современный Лисп для функционального программирования с интеграцией в Java-платформу, спроектированный для поддержки параллелизма.
Как и в любом другом Лиспе, синтаксис Clojure основан на S-выражениях, которые перед компиляцией транслируются синтаксическим анализатором в структуры данных. Синтаксический анализатор Clojure поддерживает, помимо обычных списков, синтаксис литералов для ассоциативных массивов, множеств и векторов, передавая затем все эти структуры данных компилятору. Иначе говоря, компилятор Clojure компилирует не только списковые структуры данных, но и напрямую поддерживает все указанные типы.

Хотя Clojure является расширением изначальной версии Lisp, он не совместим с Lisp’ом, то есть программа на любой из современных версий Lisp’а (за исключением, возможно, самых коротких, примитивных и, к тому же, специально подобранных примеров) либо вообще не пройдёт транслятор Clojure, либо будет выполняться неправильно. Отличия от распространённых версий Lisp’а приведены на сайте языка[5]. Вот некоторые из них:

  - идентификаторы регистро-зависимы;
  - оригинальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и ряда других синтаксических элементов;
  - утрачена многозначность значения nil (которое в Lisp обозначает и пустой указатель, и пустой список, и логическое значение «ложь») — оно означает только отсутствующее  -     - значение (пустую ссылку, подобно null в Java), для прочих значений используется специфический синтаксис;
  - многие традиционные функции поменяли имена, например, car и cdr заменены на first и rest;
  - поддерживаются одноимённые функции с различными наборами аргументов;
  - отсутствуют макросы чтения (read macros), что лишает возможности изменять синтаксис языка;
  - часть оставшихся неизменными синтаксических элементов изменили смысл;
  - появилась поддержка «ленивых» коллекций.
 Макросистема Clojure очень похожа на аналогичную систему Common Lisp, за двумя исключениями:

  - При раскрытии форм под знаком обратной кавычки , который в Clojure именуется термином «syntax-quote», происходит автоматическая явная квалификация каждого символа тем пространством имён, к которому он относится в точке определения макроса. Такой порядок исключает непреднамеренное связывание с одноимённым символом из «чужого» пространства имён при раскрытии макроса. Сослаться в макросе на символ из другого пространства имён возможно, но только путём его явной квалификации.
  - Для выделения промежуточных вычислений под знаком обратной кавычки вместо , и ,@ используются ~ и ~@ соответственно.
 
  Особенности языка
  
    - Динамическая, интерактивная разработка в REPL-цикле
    - Функции как объекты первого класса с акцентом на рекурсию, а не на основанную на побочных эффектах итерацию
    - «Ленивые» последовательности
    - Обеспечивает богатый набор неизменяемых, сохраняемых структур данных (англ.)
    - Параллельное программирование с поддержкой транзакционной памяти, агентной системы и системы динамических переменных
    - Clojure — компилируемый язык, результатом компиляции является байткод JVM
    - Тесная интеграция с Java: за счёт компиляции в байткод JVM программы на Clojure легко переносятся в любую среду с JVM. Язык также обеспечивает ряд макросов, которые      упрощают использование в нём существующих Java API. Структуры данных Clojure реализуют все стандартные интерфейсы Java, что делает легким запуск из Java программного кода  написанного на Clojure.
